# 本地提权的方法

## 内核漏洞利用

## suid的利用

## password文件的修改

Capabilitie提权

# 相关漏洞

### 什么是文件包漏洞

1. what?  					  [==返回==](#back3)<a id='tag3'></a>

    简单理解就是你在url的参数值中传递一个文件路径，而服务器的相关代码处理你的传入的值得时候恰好会因为传入的是路径而导致程序的错误

2. 如何使用

    1. 猜参数名的时候。

### 什么是php的封装器？

1. what？

    在 PHP 中，封装器（Wrappers）是一种机制，用于处理各种类型的输入和输出流。PHP 提供了一系列内置的封装器，用于处理不同类型的资源，例如文件、网络连接、数据库等。

    以下是一些常见的 PHP 封装器：

    1. `file://` 封装器：用于处理文件系统中的文件。它是默认的封装器，可以通过简单地使用文件路径访问本地文件。
    2. `http://` 和 `https://` 封装器：用于处理 HTTP 和 HTTPS 协议，可以通过 URL 访问远程 Web 资源。
    3. `ftp://` 封装器：用于处理 FTP 协议，可以进行文件传输和操作远程 FTP 服务器。
    4. `php://` 封装器：用于访问与 PHP 相关的特殊流。例如，`php://stdin` 用于从标准输入读取数据，`php://stdout` 用于向标准输出写入数据，`php://memory` 用于创建一个内存中的流等。
    5. `data://` 封装器：用于直接在 URL 中嵌入数据。可以将数据作为 URL 的一部分进行访问，而不需要实际的文件存在。
    6. `zip://` 封装器：用于处理 ZIP 压缩文件，可以读取和写入 ZIP 文件中的内容。

2. How to use？

    使用封装器时，可以通过在文件或 URL 前添加封装器的名称来指定使用的封装器，

    `$fileContents = file_get_contents('http://www.example.com');`里面的http就是一个封装器

# 相关命令

### ps

1. what？

    用于查看当前运行进程信息的命令

2. 具体实例：

    1. ps -asf | grep root

        -a:显示所有进程包括其他用户。-s表示显示进程的状态（亦可以追加状态来筛选相关的进程）。-f

    2. ps:查看当前用户所有进程

    3. -f：显示完整的进程信息

    4. -p \<PID>:指定查看进程的详细信息

    5. -U：用于指定显示该用户下面的进程

### getcap

1. what?

    用于查看文件或可执行程序的能力（capabilities）设置。通常和 `setcap`结合使用

2. 具体实例

    1. getcap -r /：表示通过递归的方式查看 `/`目录下面所有设置 `capabilities`权限的命令

### setcap

1. what?

    用于为文件或可执行程序设置能力（capabilities）

2. 具体实例

    1. `setcap <capability>[-<flag>] <file_path>`

        setcap cap_sys_admin=eip /



### ascii工具

​		下载后，直接键入ascii就可以查看每个字母对于的ascii值了

### dig

1. what?

    进行 DNS（Domain Name System）查询。获取与域名相关的信息，如域名的 IP 地址、域名服务器的信息、DNS 记录等。

2. 具体实例

    1. dig axfr @2.3.4.5 cchl.fun

        通过axfr试着向dns服务器2.3.4.5来请求cchl.fun的完整dns记录。

### file

1. what

    用于确定文件的类型。它可以根据文件的内容和特征对文件进行分类，并返回相应的描述信息。==同时它是可以读取文件的具体内容的==

2. 具体描述

    1. `-b`：仅显示文件类型，不显示文件名。
    2. `-i`：显示 MIME 类型。MIME类型由两个部分组成：媒体类型（Media Type）和子类型（Subtype）PDF文件的MIME类型为          application/pdf
    3. `-m`：指定魔术文件（Magic File）的路径，用于识别文件类型。
    4. `-z`：对压缩文件进行分析。

### ssh

1. what?

    不解释

2. 具体实例

    1. -v：显示连接的具体过程，其中几个注意点：能允许交换秘钥的方式，能允许的登陆方式（password or public_key）
    2. -i：表示指定为public_key来进行连接，同时需加上一个私钥的文件：-i private_key.txt

### gunzip

1. what?

    ​	一个解压命令,解压gz.

2. 具体实例

    1. unzip  file.zip

        ​	对zip文件进行解压

        

3. what?

    ​	一个解压命令,解压zip

4. 具体实例

    1. unzip  file.zip

        ​	对zip文件进行解压

    2. -d：指定解压后的保存目录

    3. -l：查看压缩包内部的文件结构

    4. -v：展示解压的详细内容

    5. -o：解压后用解压的文件来替代原来的压缩文件，将原来的文件删除。

### find

1. what?											[==返回==](#back5)<a id='tag5'></a>

    用于在文件系统中搜索文件和目录。具有广泛的选项和用法，可以根据不同的条件和标准进行搜索。

    如：权限，时间戳，文件内容等

2. 具体实例

    1. find / -perm /2000 2>/dev/null

        1. `/` 是指要搜索的起始路径，这里是根目录。

        2. `-perm` 是一个选项，用于指定要搜索的文件权限。

        3. `/2000` "setgid" 位的权限，表示满足权限模式为 `2000`（八进制表示）的文件。

        4. `2 > /dev/null` 是将标准错误输出重定向到 `/dev/null`，意味着将错误信息丢弃。

            `2`：在 Linux 中，标准错误输出的文件描述符为 `2`。文件描述符是一个与文件或设备相关联的整数值。

            `/dev/null`： 是一个特殊的设备文件，在 Linux 中被称为“黑洞”。它接收到的任何数据都会被丢弃，不会在终端上显示，也不会被记录。

    2. find / -perm /4000 2>/dev/null

        1. 4000：设置了 "setuid" 位的权限

### (|)管道符

1. what?

    将一个命令的输出作为另一个命令的输入进行处理，实现两个或多个命令之间的协作。通过管道，可以将一个命令的输出传递给另一个	命令进行进一步处理，实现数据流的传递和处理。	

2. 直接放入两个命令之间即可

### ll -la

 -rw-r--r-- 1 root root 123456 May 11 10:30 example.txt

1. -rw-r--r--

    1. -表示文件类型
        1. -：普通文件
        2. d：文件夹
        3. 。。。。
    2. rw-：所属用户的权限
    3. r--：所属用户的用户组的权限
    4. r--：其他的用户组的权限

2. 1     :用户表示这个文件的硬件连接数

3. root root   :分别表示 所属用户，用户属于的用户组

4. 123465：文件的大小

5. `May 11 10:30`：表示该文件的最后修改时间

6. `example.txt`表示该文件的名字

7. ==特殊权限==：在---中前两位为读写，第三位为x，但同时也有另外三个权限：suid、sgid、sticky

    1. suid：让普通用户临时拥有该文件的属主的执行权限，==suid权限只能应用在二进制可执行文件（命令）上==，而且suid权限==只能设置在属主位置上==。					（==可以用来提权==）

        增加权限u+s，移除权限u-s

    2. sgid：sgid权限一般应用在目录上，当一个目录拥有sgid权限时，任何用户在该目录下创建的文件的属组都会继承该目录的属组。

        sgid权限也使用s表示，增加权限g+s，移除权限g-s；

    3. sticky：sticky权限一般针对目录来设置，作用是只允该目录下的文件的创建者删除自己的创建的文件，不允许其他人删除文件。（root用户除外，因为root用户是超级管理员），而且sticky权限只能设置在other位置上。

        使用t表示，增加权限o+t，移除权限o-t；

    

### sudo -l

1. `sudo -l`是用来列出当前用户在sudo配置文件中拥有的==权限列表==的命令。该命令会列出当前用户可以以管理员权限运行的==命令和脚本==，以及相关的权限和约束。如果当前用户在sudo配置文件中没有相应的权限，那么执行`sudo -l`命令将会返回一个空列表。需要注意的是，执行`sudo -l`命令需要当前用户已经通过了==s====udo的身份验证。==
2. 其中sudo的身份验证一般在登陆的时候都验证

### proxychains

1. 当执行命令的时候加上该命令，表示通过代理来进行操作。但是需要修改配置，

    ![image-20230515192437727](http://image.cchl.fun/kali_image/image-20230515192437727.png)

    将该文件的行末给为这样，自己指定端口。

    <img src="http://image.cchl.fun/kali_image/image-20230515192445785.png" alt="image-20230515192445785" style="zoom:50%;" />：
    
    

# 信息的搜集的判断

## 判断是否进入入docker中

### 		cat /proc/1/cgroup					

​					`/proc` 目录是一种特殊类型的文件系统，通常被称为 procfs。包含了关于操作系统进程组织方式的信息，其中的数字 1 代表					的是 init 进程，也就是系统启动时==第一个运行==的进程。

​					`/proc/1/cgroup` 文件中存储了关于 init 进程所在的控制组（cgroup）信息，其中每一行代表一个控制组。控制组是 Linux 					内核中的一个功能，可以用来限制系统资源的使用，通过将进程分组，可以更好地对进程进行管理和资源分配。在 					`/proc/1/cgroup` 文件中，每一行由三个字段组成，分别是控制组的名称、控制组的层级结构和进程 ID（PID）。

### 			ls /.dockerenv	

​					`/.dockerenv` ==是一个标识当前进程运行在 Docker 容器内的文件==。这个文件在 Docker 容器内部中始终存在，可以通过检查					这个文			件是否存在来判断当前应用程序是否运行在 Docker 容器内部。通常，一些脚本和工具会使用这个文件来判断					当前是否在 Docker 			容器		中，并作出相应的处理。



## linux基础目录/文件知识



### ./bashrc 文件

​	 	是用户级别的 Bash Shell 配置文件，用于自定义用户的 Shell 环境和行为



### /bin/sh

在许多系统中，`/bin/sh`实际上是指向其他Shell解释器的符号链接，例如Bash Shell（/bin/bash）、Dash Shell（/bin/dash）或其他兼容的Shell。这是因为在现代系统中，Bash Shell通常作为默认的Shell解释器，而`/bin/sh`被链接到Bash Shell的路径。

因此，当您在命令中使用`/bin/sh`时，它实际上是指定使用系统默认的Shell解释器来执行相应的命令。具体使用哪种Shell取决于系统配置和符号链接的设置。

### /tmp/目录下执行脚本  ，why?

将代码执行限制在`/tmp/`目录是出于安全的考虑。`/tmp/`目录通常是==可写==的，==因此攻击者可以在该目录中创建和运行恶意代码==，例如将代码执行限制在`/tmp/`目录下，可以避免攻击者在系统的其他位置运行恶意代码，限制了其能够进行攻击的范围，提高了系统的安全性。



### /bin/bash

1. what?

    `/bin/bash` 是在常见的Linux系统中找到的默认shell路径。

2. 直接调用即可。

### /usr/share/wordlists

1. what?

    该路径下包含了kali中的众多字典。

### /etc/passwd

1. what?

    用来存储用户信息的

2. 具体解释

    ![image-20230517161033703](http://image.cchl.fun/kali_image/image-20230517161033703.png)

    每一行使用“：”分隔开，共有七个字段。

    1. 账号名称

        就是账号，用来对应UID的。

    2. 密码

        早期UNIX系统的密码就放在这字段上，后来将密码数据字段的数据改放到/etc/passwd 中了，所以这里你会看到一个“x”。

    3. UID

        这个是用户标识符：

        1. 0（系统管理员）当UID为0时，代表这个账号是“系统管理员”

        2. 1~499（系统用户）保留给系统使用的ID，默认500以下的数字让给系统作为保留账号只是一个习惯

        3. 1~99：由distributions自行创建的系统账号

        4. 100~499：若用户有系统账号需求时，可以使用的账号UID

        5. 500~65535（可登陆账号）给一般用户用的

    4. GID

        这个是用户组标记符

    5. 用户信息说明列

        这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已。不过，如果你提供使用finger的功能时，这个字段可以提供很多的信息

    6. 主文件夹

        这是用户的主文件夹。如果你想修改某个账号的主文件夹只需要对这个字段进行修改。默认的用户主文件夹在/home/yourIDname中，root的主文件夹在/root中。标记了用户可以使用的文件。
    
    7. 命令解释器：
    
        就是你的shell是通过上面执行的。

### Apache下的robots.txt文件					

1. what？								[==返回==](#back1)<a id='tag1'></a>

    当 Apache 作为 Web 服务器发布网页时，`robots.txt` 是一个用于指示搜索引擎爬虫（web crawler）的文本文件，用于管理网站的爬行行为。

    ```
    User-agent: *
    Disallow: /private/
    Disallow: /temp/
    ```

    - `User-agent: *` 表示对所有爬虫生效，也就是适用于所有搜索引擎爬虫。
    - `Disallow: /private/` 指示爬虫不应该访问位于 `/private/` 目录下的任何页面或资源。这是为了防止搜索引擎爬虫访问网站的敏感或私密内容。
    - `Disallow: /temp/` 指示爬虫不应该访问位于 `/temp/` 目录下的任何页面或资源。这可能是临时文件或临时目录，不希望被搜索引擎爬取。

    `robots.txt` 文件应该位于网站的根目录下，例如 `http://www.example.com/robots.txt`。搜索引擎爬虫在访问网站之前会检查这个文件，以了解有关网站的爬行规则。爬虫将尊重 `robots.txt` 文件中的指示，遵守相应的访问限制。

    需要注意的是，`robots.txt` 文件只是一种建议，而不是强制规则。

2. ==这也是手工测试的时候必须访问的目录环境==

## 渗透的底蕴

1. 9200一般是Elasticsearch在使用，为一个python相关服务。有远程执行漏洞。

    

2. what is Tornado?

    Tornado 是一个基于 Python 的开源 Web 应用程序框架和异步网络库。它由 FriendFeed（现在属于 Facebook）开发并开源，旨在提供高性能和可伸缩性的 Web 应用程序开发解决方案。

    Tornado 的主要特点包括：

    1. 异步和非阻塞：Tornado 使用基于事件循环的异步 I/O 模型，使得它能够处理大量并发连接而不会阻塞或消耗太多系统资源。这使得它非常适合构建高性能的网络应用程序，特别是在需要处理大量并发请求的场景下。
    2. 轻量级：Tornado 的核心代码库相对较小，依赖较少，因此可以轻松集成到现有的应用程序中，或作为一个独立的服务来构建 Web 服务。
    3. 支持异步请求处理：Tornado 提供了异步的请求处理机制，可以轻松处理长轮询（long polling）、WebSockets 和其他实时通信协议。
    4. 内置的 Web 服务器：Tornado 包含一个内置的非常快速的 HTTP 服务器，因此可以直接部署和运行 Tornado 应用程序，而无需额外的 Web 服务器软件。
    5. 支持模板引擎：Tornado 提供了内置的模板引擎，使得开发人员可以方便地构建动态的、可定制的 Web 页面。

    Tornado 可以用于构建各种类型的 Web 应用程序，包括实时聊天应用、实时博客平台、Web API 服务等。它在性能和可伸缩性方面的优势使其成为处理大量并发请求的理想选择

# 基础知识

### Capabilitises

1. what?                                                       [==返回==](#back5)<a id='tag5'></a>   

    是一种安全机制，用于在进程级别上控制对特定系统操作的访问权限。它们提供了一种细粒度的权限控制，使得进程可以具有特定的权限而不必以完全特权运行

    具体的各个权限参考：http://man7.org/linux/man-pages/man7/capabilities.7.html

2. 相关漏洞与使用

    1. setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap

        设置当前用户对 `/usr/bin/dumpcap`的程序拥有 `cap_net_raw,cap_net_admin`的权限，`dumpcap`是 `wireshark`进行抓包的底层命令。通过这个设置可以让linux上普通用户按照的 `wireshark`能够正常的抓包。

    2. 相关权限

        1. CAP_SYS_PTRACE

            这个权限就是可以调试其他系统权限的权限，他是有一定提权的可能的。

### dns相关知识点

#### 区域传输（axfr）

1. what?                                            [==返回==](#back2)<a id='tag2'></a>

    是DNS系统中用于在主DNS服务器和辅助DNS服务器之间传输完整区域数据的机制。它通过主服务器响应辅助服务器的AXFR请求，使辅助服务器能够更新自己的区域副本，以提供可靠的域名解析服务。

2. Notice

    axfr是在安全实践中是不应该对所有的用户开发的，一般应该只允许同一个域下面的不同概念的dns服务器能够相互的axfr通过53/tcp进行dns的同步（这是需要手工配置的）.当主DNS服务器上的区域数据发生变化时（例如添加、删除或修改记录），辅助DNS服务器需要更新自己的数据，以保持与主服务器的一致性。这时就需要进行区域传输。

#### 各种解析

1. NS (Name Server) 记录： NS 记录用于指定该域名的权威域名服务器（Name Server）。它指定负责管理该域名的 DNS 服务器，提供与该域名相关的 DNS 信息。
2. MX (Mail Exchanger) 记录： MX 记录用于指定接收域名的电子邮件的邮件服务器。它将域名映射到一个或多个邮件服务器，以指定邮件交换的目标。



### 53端口

53端口是dns服务器占用，其中53/udp是用来进行dns功能。==53/tcp==是在同一个域下的不同dns主机进行相互通讯的端口（一般来讲）。

### url中的#号

#为片段标识符，是用于标识网页中特定部分或锚点的标记。当浏览器加载包含片段标识符的 URL 时，它会滚动到相应的片段或特定位置，使用户可以直接导航到该位置。

以下是一些常见的用法和作用：					[==返回==](#back1)<a id='tag1'></a>

1. 页面内部导航：在单个网页中，可以使用片段标识符来标识不同的部分，用户可以直接跳转到页面中的特定部分，无需手动滚动。

    例如：`https://www.example.com/page.html#section2`

2. 锚点链接：在一个网页中，可以使用片段标识符来创建内部链接，使用户从一个页面跳转到同一页面的不同部分。

    例如：`<a href="#section2">跳转到第二部分</a>`

3. 页面共享和书签：通过包含片段标识符的 URL，可以在网页间共享特定位置的链接。这对于在社交媒体上分享感兴趣的内容或创建书签非常有用。

    例如：`https://www.example.com/article.html#summary`

需要注意的是，片段标识符只在客户端（浏览器）中起作用，不会发送给服务器。因此，服务器不会根据片段标识符来提供不同的内容。片段标识符仅用于客户端的导航和定位。

